"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[36339],{3760:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var t=a(87462),s=(a(67294),a(3905));const r={sidebar_position:2},o="High Availability Installation",l={unversionedId:"deploy/replication",id:"deploy/replication",title:"High Availability Installation",description:"If you intend to run Walrus in production, you need to follow the high-avaialbility installation.",source:"@site/docs/deploy/replication.md",sourceDirName:"deploy",slug:"/deploy/replication",permalink:"/docs/deploy/replication",draft:!1,editUrl:"https://github.com/seal-io/docs/edit/main/docs/deploy/replication.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docs",previous:{title:"Standalone Installation",permalink:"/docs/deploy/standalone"},next:{title:"Airgap Installation",permalink:"/docs/deploy/airgap"}},i={},p=[{value:"Configuring TLS",id:"configuring-tls",level:2},{value:"Default method, using TLS termination",id:"default-method-using-tls-termination",level:3},{value:"Using a Self-Signed Certificate",id:"using-a-self-signed-certificate",level:3},{value:"Use ACME to Generate Trusted Certificate",id:"use-acme-to-generate-trusted-certificate",level:3},{value:"Using a Custom Certificate",id:"using-a-custom-certificate",level:3},{value:"Configuring the Database",id:"configuring-the-database",level:2}],u={toc:p};function c(e){let{components:n,...a}=e;return(0,s.kt)("wrapper",(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"high-availability-installation"},"High Availability Installation"),(0,s.kt)("p",null,"If you intend to run Walrus in production, you need to follow the high-avaialbility installation."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Prerequisites:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"An highly-available Kubernetes cluster is required as the runtime cluster."),(0,s.kt)("li",{parentName:"ul"},"Kubernetes cluster supports Ingress."),(0,s.kt)("li",{parentName:"ul"},"Each Kubernetes node should have at least 4 CPU cores and 8GiB memory."),(0,s.kt)("li",{parentName:"ul"},"At least 50GB of free disk space on each Kubernetes node."),(0,s.kt)("li",{parentName:"ul"},"Ports 80 and 443 are opened on the nodes."))),(0,s.kt)("p",null,"You can fill in the following YAML with relevant information and use the ",(0,s.kt)("inlineCode",{parentName:"p"},"kubectl apply")," command to complete the high availability deployment."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Create the Walrus deployment YAML:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"vim walrus.yaml\n")),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Fill in the following YAML:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: walrus-system\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "entrance"\nspec:\n  defaultBackend:\n    service:\n      name: walrus\n      port:\n        number: 80\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "configuration"\nstringData:\n  local_environment_mode: "disabled"\n  enable_tls: "false"\n  db_driver: "postgres"\n  db_user: "root"\n  db_password: "Root123"\n  db_name: "walrus"\n  minio_root_user: "minio"\n  minio_root_password: "Minio123"\n  minio_bucket: "walrus"\n---\n\n\n# Database\n#\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  namespace: walrus-system\n  name: database-script\ndata:\n  "init.sh": |\n    #!/usr/bin/env bash\n\n    set -o errexit\n    set -o nounset\n    set -o pipefail\n\n    if [[ ! -d ${PGDATA} ]]; then\n      mkdir -p ${PGDATA}\n      chown 9999:9999 ${PGDATA}\n    fi\n\n  "probe.sh": |\n    #!/usr/bin/env bash\n\n    set -o errexit\n    set -o nounset\n    set -o pipefail\n\n    psql --no-password --username=${POSTGRES_USER} --dbname=${POSTGRES_DB} --command="SELECT 1"\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: database\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "database"\n  ports:\n    - name: conn\n      port: 5432\n      targetPort: conn\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  namespace: walrus-system\n  name: database\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "database"\nspec:\n  # When a PVC does not specify a storageClassName,\n  # the default StorageClass is used.\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 8Gi\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  namespace: walrus-system\n  name: database\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "database"\n    "app.kubernetes.io/name": "postgres"\nspec:\n  strategy:\n    type: Recreate\n  replicas: 1\n  selector:\n    matchLabels:\n      "app.kubernetes.io/part-of": "walrus"\n      "app.kubernetes.io/component": "database"\n      "app.kubernetes.io/name": "postgres"\n  template:\n    metadata:\n      labels:\n        "app.kubernetes.io/part-of": "walrus"\n        "app.kubernetes.io/component": "database"\n        "app.kubernetes.io/name": "postgres"\n    spec:\n      automountServiceAccountToken: false\n      restartPolicy: Always\n      initContainers:\n        - name: init\n          image: postgres:16.1\n          imagePullPolicy: IfNotPresent\n          command:\n            - /script/init.sh\n          env:\n            - name: PGDATA\n              value: /var/lib/postgresql/data/pgdata\n          volumeMounts:\n            - name: script\n              mountPath: /script\n            - name: data\n              mountPath: /var/lib/postgresql/data\n      containers:\n        - name: postgres\n          image: postgres:16.1\n          imagePullPolicy: IfNotPresent\n          resources:\n            limits:\n              cpu: \'4\'\n              memory: \'8Gi\'\n            requests:\n              cpu: \'500m\'\n              memory: \'512Mi\'\n          securityContext:\n            runAsUser: 9999\n          ports:\n            - name: conn\n              containerPort: 5432\n          env:\n            - name: POSTGRES_USER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_user\n            - name: POSTGRES_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_password\n            - name: POSTGRES_DB\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_name\n            - name: PGDATA\n              value: /var/lib/postgresql/data/pgdata\n          startupProbe:\n            failureThreshold: 10\n            periodSeconds: 5\n            exec:\n              command:\n                - /script/probe.sh\n          readinessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 5\n            exec:\n              command:\n                - /script/probe.sh\n          livenessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 10\n            exec:\n              command:\n                - /script/probe.sh\n          volumeMounts:\n            - name: script\n              mountPath: /script\n            - name: data\n              mountPath: /var/lib/postgresql/data\n      volumes:\n        - name: script\n          configMap:\n            name: database-script\n            defaultMode: 0555\n        - name: data\n          persistentVolumeClaim:\n            claimName: database\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  namespace: walrus-system\n  name: minio\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "minio"\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 8Gi\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: minio\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "minio"\n  ports:\n    - name: minio\n      port: 9000\n      targetPort: minio\n---\napiVersion: apps/v1 #  for k8s versions before 1.9.0 use apps/v1beta2  and before 1.8.0 use extensions/v1beta1\nkind: Deployment\nmetadata:\n  # This name uniquely identifies the Deployment\n  name: minio\n  namespace: walrus-system\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "minio"\n    "app.kubernetes.io/name": "minio"\nspec:\n  selector:\n    matchLabels:\n      "app.kubernetes.io/part-of": "walrus"\n      "app.kubernetes.io/component": "minio"\n      "app.kubernetes.io/name": "minio"\n  strategy:\n    type: Recreate\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        "app.kubernetes.io/part-of": "walrus"\n        "app.kubernetes.io/component": "minio"\n        "app.kubernetes.io/name": "minio"\n    spec:\n      volumes:\n      - name: storage\n        persistentVolumeClaim:\n          claimName: minio\n      containers:\n      - name: minio\n        image: minio/minio:RELEASE.2024-02-26T09-33-48Z\n        args:\n        - server\n        - /storage\n        resources:\n          limits:\n            cpu: \'1\'\n            memory: \'1Gi\'\n          requests:\n            cpu: \'500m\'\n            memory: \'512Mi\'\n        ports:\n        - name: minio\n          containerPort: 9000\n        env:\n        - name: MINIO_ROOT_USER\n          valueFrom:\n            secretKeyRef:\n              name: walrus\n              key: minio_root_user\n        - name: MINIO_ROOT_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: walrus\n              key: minio_root_password\n        volumeMounts:\n        - name: storage\n          mountPath: "/storage"\n\n# Identity Access Manager\n#\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  namespace: walrus-system\n  name: identity-access-manager-script\ndata:\n  "init.sh": |\n    #!/usr/bin/env bash\n\n    set -o errexit\n    set -o nounset\n    set -o pipefail\n\n    # validate database\n    set +o errexit\n    while true; do\n      if psql --command="SELECT 1" "${DB_SOURCE}" >/dev/null 2>&1; then\n        break\n      fi\n      echo "waiting db to be ready ..."\n      sleep 2s\n    done\n    set -o errexit\n\n    # mutate app configuration\n    cp -f /conf/app.conf app.conf\n    sed -i \'/^tableNamePrefix =.*/d\' app.conf\n    echo "tableNamePrefix = casdoor_" >>app.conf\n    sed -i \'/^driverName =.*/d\' app.conf\n    echo "driverName = \\"${DB_DRIVER}\\"" >>app.conf\n    sed -i \'/^dataSourceName =.*/d\' app.conf\n    echo "dataSourceName = \\"${DB_SOURCE}\\"" >>app.conf\n    sed -i \'/^sessionConfig =.*/d\' app.conf\n    echo \'sessionConfig = {"enableSetCookie":true,"cookieName":"casdoor_session_id","cookieLifeTime":3600,"providerConfig":"/var/run/casdoor","gclifetime":3600,"domain":"","secure":false,"disableHTTPOnly":false}\' >>app.conf\n    sed "s#${DB_PASSWORD}#***#g" app.conf\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: identity-access-manager\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "identity-access-manager"\n  ports:\n    - name: http\n      port: 8000\n      targetPort: http\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  namespace: walrus-system\n  name: identity-access-manager\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "identity-access-manager"\n    "app.kubernetes.io/name": "casdoor"\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      "app.kubernetes.io/part-of": "walrus"\n      "app.kubernetes.io/component": "identity-access-manager"\n      "app.kubernetes.io/name": "casdoor"\n  template:\n    metadata:\n      labels:\n        "app.kubernetes.io/part-of": "walrus"\n        "app.kubernetes.io/component": "identity-access-manager"\n        "app.kubernetes.io/name": "casdoor"\n    spec:\n      automountServiceAccountToken: false\n      restartPolicy: Always\n      initContainers:\n        - name: init\n          image: sealio/casdoor:v1.515.0-seal.1\n          imagePullPolicy: IfNotPresent\n          workingDir: /tmp/conf\n          command:\n            - /script/init.sh\n          env:\n            - name: DB_DRIVER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_driver\n            - name: DB_USER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_user\n            - name: DB_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_password\n            - name: DB_NAME\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_name\n            - name: DB_SOURCE\n              value: $(DB_DRIVER)://$(DB_USER):$(DB_PASSWORD)@database:5432/$(DB_NAME)?sslmode=disable\n          volumeMounts:\n            - name: script\n              mountPath: /script\n            - name: config\n              mountPath: /tmp/conf\n      containers:\n        - name: casdoor\n          image: sealio/casdoor:v1.515.0-seal.1\n          imagePullPolicy: IfNotPresent\n          resources:\n            limits:\n              cpu: \'2\'\n              memory: \'4Gi\'\n            requests:\n              cpu: \'500m\'\n              memory: \'512Mi\'\n          workingDir: /\n          command:\n            - /casdoor\n            - --createDatabase=true\n          ports:\n            - name: http\n              containerPort: 8000\n          startupProbe:\n            failureThreshold: 10\n            periodSeconds: 5\n\n            tcpSocket:\n              port: 8000\n          readinessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 5\n            tcpSocket:\n              port: 8000\n          livenessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 10\n            tcpSocket:\n              port: 8000\n          volumeMounts:\n            - name: config\n              mountPath: /conf\n            - name: data\n              mountPath: /var/run/casdoor\n      volumes:\n        - name: script\n          configMap:\n            name: identity-access-manager-script\n            defaultMode: 0500\n        - name: config\n          emptyDir: { }\n        - name: data\n          emptyDir: { }\n---\n\n\n# Walrus server\n#\n## RBAC for installing third-party applications.\n##\n## Since the installation of some third-party software has permission granting operations,\n## it will contain some resource global operation permissions, but only for granting.\n##\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nrules:\n  - apiGroups:\n      - \'*\'\n    resources:\n      - \'*\'\n    verbs:\n      - \'*\'\n  - nonResourceURLs:\n      - \'*\'\n    verbs:\n      - \'*\'\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nsubjects:\n  - kind: ServiceAccount\n    name: walrus\n    namespace: walrus-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: walrus\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: walrus-system\n  name: walrus-enable-workflow\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nrules:\n  - apiGroups:\n      - argoproj.io\n    resources:\n      - "*"\n    verbs:\n      - "*"\n  - apiGroups:\n      - ""\n    resources:\n      - "persistentvolumeclaims"\n      - "persistentvolumeclaims/finalizers"\n    verbs:\n      - "*"\n  - apiGroups:\n      - ""\n    resources:\n      - "pods/exec"\n    verbs:\n      - "*"\n  - apiGroups:\n      - "policy"\n    resources:\n      - "poddisruptionbudgets"\n    verbs:\n      - "*"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  namespace: walrus-system\n  name: walrus-enable-workflow\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nsubjects:\n  - kind: ServiceAccount\n    name: walrus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: walrus-enable-workflow\n## RBAC for deploying\n##\n## As limiting in the walrus-system, it can be safe to make all verbs as "*".\n##\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  namespace: walrus-system\n  name: walrus-deployer\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: walrus-system\n  name: walrus-deployer\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nrules:\n  - apiGroups:\n      - "batch"\n    resources:\n      - "jobs"\n    verbs:\n      - "*"\n  - apiGroups:\n      - ""\n    resources:\n      - "secrets"\n      - "pods"\n      - "pods/log"\n    verbs:\n      - "*"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  namespace: walrus-system\n  name: walrus-deployer\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nsubjects:\n  - kind: ServiceAccount\n    name: walrus-deployer\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: walrus-deployer\n## RBAC for running workflow\n##\n## As limiting in the walrus-system, it can be safe to make all verbs as "*".\n##\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  namespace: walrus-system\n  name: walrus-workflow\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: walrus-system\n  name: walrus-workflow\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nrules:\n  # The below rules are used for running workflow.\n  - apiGroups:\n      - ""\n    resources:\n      - "pods"\n    verbs:\n      - "get"\n      - "watch"\n      - "patch"\n  - apiGroups:\n      - ""\n    resources:\n      - "pods/logs"\n    verbs:\n      - "get"\n      - "watch"\n  - apiGroups:\n      - ""\n    resources:\n      - "secrets"\n    verbs:\n      - "get"\n  - apiGroups:\n      - "argoproj.io"\n    resources:\n      - "workflowtasksets"\n    verbs:\n      - "watch"\n      - "list"\n  - apiGroups:\n      - "argoproj.io"\n    resources:\n      - "workflowtaskresults"\n    verbs:\n      - "create"\n      - "patch"\n  - apiGroups:\n      - "argoproj.io"\n    resources:\n      - "workflowtasksets/status"\n    verbs:\n      - "patch"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  namespace: walrus-system\n  name: walrus-workflow\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nsubjects:\n  - kind: ServiceAccount\n    name: walrus-workflow\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: walrus-workflow\n## Storage\n##\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nspec:\n  # When a PVC does not specify a storageClassName,\n  # the default StorageClass is used.\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 500Mi\n## Service\n##\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: walrus\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n  sessionAffinity: ClientIP\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n## Deployment\n##\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n    "app.kubernetes.io/name": "walrus-server"\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      "app.kubernetes.io/part-of": "walrus"\n      "app.kubernetes.io/component": "walrus"\n      "app.kubernetes.io/name": "walrus-server"\n  template:\n    metadata:\n      labels:\n        "app.kubernetes.io/part-of": "walrus"\n        "app.kubernetes.io/component": "walrus"\n        "app.kubernetes.io/name": "walrus-server"\n    spec:\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n            - weight: 100\n              podAffinityTerm:\n                topologyKey: "kubernetes.io/hostname"\n                labelSelector:\n                  matchExpressions:\n                    - key: "app.kubernetes.io/component"\n                      operator: In\n                      values:\n                        - "walrus"\n                    - key: "app.kubernetes.io/part-of"\n                      operator: In\n                      values:\n                        - "walrus"\n                    - key: "app.kubernetes.io/name"\n                      operator: In\n                      values:\n                        - "walrus-server"\n      restartPolicy: Always\n      serviceAccountName: walrus\n      containers:\n        - name: walrus-server\n          image: sealio/walrus:v0.6.0\n          imagePullPolicy: Always\n          resources:\n            limits:\n              cpu: \'4\'\n              memory: \'8Gi\'\n            requests:\n              cpu: \'500m\'\n              memory: \'512Mi\'\n          env:\n            - name: DB_DRIVER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_driver\n            - name: DB_USER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_user\n            - name: DB_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_password\n            - name: DB_NAME\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_name\n            - name: MINIO_ROOT_USER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: minio_root_user\n            - name: MINIO_ROOT_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: minio_root_password\n            - name: MINIO_BUCKET\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: minio_bucket\n            - name: SERVER_SETTING_LOCAL_ENVIRONMENT_MODE\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: local_environment_mode\n            - name: SERVER_ENABLE_TLS\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: enable_tls\n            - name: SERVER_DATA_SOURCE_ADDRESS\n              value: $(DB_DRIVER)://$(DB_USER):$(DB_PASSWORD)@database:5432/$(DB_NAME)?sslmode=disable\n            - name: SERVER_CASDOOR_SERVER\n              value: http://identity-access-manager:8000\n          ports:\n            - name: http\n              containerPort: 80\n            - name: https\n              containerPort: 443\n          startupProbe:\n            failureThreshold: 10\n            periodSeconds: 5\n            httpGet:\n              port: 80\n              path: /readyz\n          readinessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 5\n            httpGet:\n              port: 80\n              path: /readyz\n          livenessProbe:\n            failureThreshold: 10\n            timeoutSeconds: 5\n            periodSeconds: 10\n            httpGet:\n              httpHeaders:\n                - name: "User-Agent"\n                  value: ""\n              port: 80\n              path: /livez\n          volumeMounts:\n            - name: custom-tls\n              mountPath: /etc/walrus/ssl\n            - name: data\n              mountPath: /var/run/walrus\n      volumes:\n        - name: custom-tls\n          secret:\n            secretName: walrus-custom-tls\n            optional: true\n        - name: data\n          persistentVolumeClaim:\n            claimName: walrus\n')),(0,s.kt)("p",null,"After using the above YAML for high-availability deployment, Walrus will not create a local Environment under the default Project, nor will the Kubernetes cluster where Walrus is deployed be used as a local Kubernetes Connector."),(0,s.kt)("p",null,"If you want to deploy Walrus' Kubernetes cluster as a local Kubernetes Connector after high-availability deployment, that is, allow Walrus to manage the cluster, you need to make the following modifications."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},' apiVersion: v1\n kind: Secret\n metadata:\n   namespace: walrus-system\n   name: walrus\n   labels:\n     "app.kubernetes.io/part-of": "walrus"\n     "app.kubernetes.io/component": "configuration"\n stringData:\n-  local_environment_mode: "disabled"\n+  local_environment_mode: "kubernetes"\n   enable_tls: "false"\n   db_driver: "postgres"\n   db_user: "root"\n   db_password: "Root123"\n   db_name: "walrus"\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},' apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding\n metadata:\n   name: walrus\n   labels:\n     "app.kubernetes.io/part-of": "walrus"\n     "app.kubernetes.io/component": "walrus"\n subjects:\n   - kind: ServiceAccount\n     name: walrus\n     namespace: walrus-system\n roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n-  name: walrus\n+  name: cluster-admin\n')),(0,s.kt)("ol",{start:3},(0,s.kt)("li",{parentName:"ol"},"Apply the YAML:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl apply -f walrus.yaml\n")),(0,s.kt)("h2",{id:"configuring-tls"},"Configuring TLS"),(0,s.kt)("h3",{id:"default-method-using-tls-termination"},"Default method, using TLS termination"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/TLS_termination_proxy"},"TLS termination")," is usually performed by a reverse proxy service, that is, the Ingress Service of the cluster provides the TLS service."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"The reverse proxy service can use HTTP requests to Walrus, and you should set Walrus's session cookie ",(0,s.kt)("inlineCode",{parentName:"li"},"walrus_session")," to ",(0,s.kt)("inlineCode",{parentName:"li"},"Secure: true")," to prevent man-in-the-middle attacks."))),(0,s.kt)("h3",{id:"using-a-self-signed-certificate"},"Using a Self-Signed Certificate"),(0,s.kt)("p",null,"Walrus can issue a self-signed HTTPS certificate for test purposes."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl apply")," to add a NodePort type Service.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'cat <<EOF | kubectl apply -f -\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "entrance"\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n  sessionAffinity: ClientIP\n  type: NodePort\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n    - name: https\n      port: 443\n      targetPort: https\n\nEOF\n')),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the TLS option in Secret.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'kubectl -n walrus-system patch secret walrus --type=\'json\' -p=\'[{"op":"replace","path":"/data/enable_tls","value":"dHJ1ZQ=="}]\'\n')),(0,s.kt)("ol",{start:3},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl delete")," to delete Ingress.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl -n walrus-system delete ingress walrus\n")),(0,s.kt)("ol",{start:4},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl rollout")," to restart Walrus.")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},'After changing the access method, you need to adjust the "Server Address" in "System Settings".'))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl -n walrus-system rollout restart deployment/walrus\n")),(0,s.kt)("ol",{start:5},(0,s.kt)("li",{parentName:"ol"},"Due to lack of the access pointer provided by Ingress, it can be accessed by kubectl's port-forward.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"sudo kubectl -n walrus-system port-forward service/walrus 443:443\n")),(0,s.kt)("h3",{id:"use-acme-to-generate-trusted-certificate"},"Use ",(0,s.kt)("a",{parentName:"h3",href:"https://letsencrypt.org/docs/challenge-types"},"ACME")," to Generate Trusted Certificate"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},'If the cluster can perform ACME challenges at the Ingress Controller level via CertManager, please refer to "Using TLS Termination".'))),(0,s.kt)("p",null,"You can use Let's Encrypt to issue a 90-day HTTPS certificate. The renewal of this certificate is performed by Walrus automatically."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Prerequisites:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"The cluster should support the LoadBalancer type of Service."),(0,s.kt)("li",{parentName:"ul"},"Provide a domain name, for example, ",(0,s.kt)("inlineCode",{parentName:"li"},"walrus.mydomain.com"),"."))),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl apply")," to add a LoadBalancer type of Service.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'cat <<EOF | kubectl apply -f -\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "entrance"\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n  sessionAffinity: ClientIP\n  type: LoadBalancer\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n    - name: https\n      port: 443\n      targetPort: https\n\nEOF\n')),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Use the ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl get")," command to wait for the LoadBalancer type of service to get an Ingress IP.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"until [[ -n $(kubectl -n walrus-system get service walrus --template=\"{{range .status.loadBalancer.ingress}}{{.ip}}{{end}}\") ]]; do :; done && \\\n  kubectl get service walrus -o=jsonpath='{.status.loadBalancer.ingress[0].ip}'\n\n")),(0,s.kt)("ol",{start:3},(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"On the DNS configuration panel, add the above A Record pointing to the output IP address.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Use ",(0,s.kt)("inlineCode",{parentName:"p"},"kubectl patch")," to modify the TLS option in Secret."))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'kubectl -n walrus-system patch secret walrus --type=\'json\' -p=\'[{"op":"replace","path":"/data/enable_tls","value":"dHJ1ZQ=="}]\'\n')),(0,s.kt)("ol",{start:5},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl delete")," to delete Ingress.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl -n walrus-system delete ingress walrus\n")),(0,s.kt)("ol",{start:6},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the environment variables of Walrus to respond to the ACME challenge.")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},'After changing the access method, you need to adjust the "Server Address" in "System Settings".'))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'export DNS_NAME=""; kubectl -n walrus-system patch deployment walrus --type json -p "[{\\"op\\":\\"add\\",\\"path\\":\\"/spec/template/spec/containers/0/env/-\\",\\"value\\":{\\"name\\":\\"SERVER_TLS_AUTO_CERT_DOMAINS\\",\\"value\\":\\"${DNS_NAME}\\"}}]"\n')),(0,s.kt)("h3",{id:"using-a-custom-certificate"},"Using a Custom Certificate"),(0,s.kt)("p",null,"A custom certificate is an HTTPS  certificate issued by a certificate authority."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Prerequisites:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"Get the content of the HTTPS service private key PEM file, note it as PRIVATE_KEY_FILE_CONTENT."),(0,s.kt)("li",{parentName:"ul"},"Get the content of the HTTPS service certificate (chain) PEM file, note it as CERT_FILE_CONTENT."),(0,s.kt)("li",{parentName:"ul"},"If there is a (non-publicly trusted) CA certificate, get the corresponding PEM file content and concatenate it to CERT_FILE_CONTENT."))),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Use the ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl apply")," command to add a Secret with custom certificate content.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'export PRIVATE_KEY_FILE_CONTENT=""; export CERT_FILE_CONTENT=""; cat <<EOF | kubectl apply -f -\n\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  namespace: walrus-system\n  name: walrus-custom-tls\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "configuration"\ntype: kubernetes.io/tls\nstringData:\n  "tls.crt": "\\${CERT_FILE_CONTENT}"\n  "tls.key": "\\${PRIVATE_KEY_FILE_CONTENT}"\n\nEOF\n')),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the TLS option in Secret.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'kubectl -n walrus-system patch secret walrus --type=\'json\' -p=\'[{"op":"replace","path":"/data/enable_tls","value":"dHJ1ZQ=="}]\'\n')),(0,s.kt)("ol",{start:3},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl delete")," to delete Ingress.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl -n walrus-system delete ingress walrus\n")),(0,s.kt)("ol",{start:4},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the environment variables of Walrus to enable the custom certificate.")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},'After changing the access method, you need to adjust the "Server Address" in "System Settings".'))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'kubectl -n walrus-system patch deployment walrus --type json \\\n-p \'[{"op":"add","path":"/spec/template/spec/containers/0/env/-","value":{"name":"SERVER_TLS_CERT_FILE","value":"/etc/walrus/ssl/tls.crt"}},{"op":"add","path":"/spec/template/spec/containers/0/env/-","value":{"name":"SERVER_TLS_PRIVATE_KEY_FILE","value":"/etc/walrus/ssl/tls.key"}}]\'\n')),(0,s.kt)("h2",{id:"configuring-the-database"},"Configuring the Database"),(0,s.kt)("p",null,"Walrus relies on ",(0,s.kt)("a",{parentName:"p",href:"https://www.postgresql.org/"},"PostgreSQL")," relational database for data storage."),(0,s.kt)("p",null,"By default, Walrus will run an instance of PostgresSQL within the running container, which is can lead to potential data loss. In an HA install, users must provide an external PostgreSQL instance."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"The following commands override previous variables by repeatedly adding duplicate environment variables, which may receive a warning from Kubernetes."))),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the environment variables of IdentifyAccessManager to connect to the external data source.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'# use add operation to override existing env.\nexport DB_SOURCE=""; kubectl -n walrus-system patch deployment identity-access-manager --type json \\\n-p "[{\\"op\\":\\"add\\",\\"path\\":\\"/spec/template/spec/initContainers/0/env/-\\",\\"value\\":{\\"name\\":\\"DB_SOURCE\\",\\"value\\":\\"${DB_SOURCE}\\"}}]"\n')),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the environment variables of Walrus to connect to the external data source.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'# use add operation to override existing env.\nexport DB_SOURCE=""; kubectl -n walrus-system patch deployment walrus --type json \\\n-p "[{\\"op\\":\\"add\\",\\"path\\":\\"/spec/template/spec/containers/0/env/-\\",\\"value\\":{\\"name\\":\\"SERVER_DATA_SOURCE_ADDRESS\\",\\"value\\":\\"${DB_SOURCE}\\"}}]"\n')))}c.isMDXComponent=!0}}]);